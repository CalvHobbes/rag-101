RAG Ingestion Traceability – Basic Level

Why this document exists

This document describes a minimal, beginner-friendly approach to adding traceability in the ingestion phase of a RAG system.

It is meant for:
	•	Learning how production RAG systems are structured
	•	Debugging ingestion issues without complex tooling
	•	Building habits that scale later

At this stage, simplicity > completeness.

⸻

What problems we want to solve (only these)

At a basic level, traceability should help you answer:
	1.	Which document was ingested?
	2.	Did ingestion succeed or fail?
	3.	How many chunks were created?
	4.	Which embedding model was used?
	5.	If something failed, where did it fail?

If your setup answers these, it is good enough to move forward.

⸻

Core idea

Use IDs + structured logs + metadata.

Do not start with:
	•	Distributed tracing
	•	Per-step latency metrics
	•	Full observability platforms

⸻

The three things you track

1. Ingestion Run

One execution of your ingestion script or pipeline.

Log once per run:
	•	ingestion_run_id
	•	run_timestamp
	•	pipeline_version
	•	embedding_model_version

Example (conceptual):

Ingestion run 2026-01-14-001 using text-embedding-3-small

⸻

2. Document

One record per document.

This is the most important level.

Log per document:
	•	document_id
	•	source_name (filename or URL)
	•	loader_used
	•	chunk_count
	•	ingestion_status (success / failed)
	•	error_message (if failed)

If you only do this part, you are already ahead of many prototypes.

⸻

3. Chunk (minimal)

Store this as metadata with the vector, not as logs.

Required chunk metadata:
	•	chunk_id
	•	document_id
	•	chunk_index
	•	char_count or token_count
	•	embedding_model_version

No need to trace chunk creation step-by-step.

⸻

Minimal data model (mental model)

You should be able to say:

This chunk → came from this document → in this ingestion run → using this embedding model

That is the entire goal.

⸻

Basic error handling rules
	•	If one document fails, continue with others
	•	Always log the failure with document_id
	•	Never fail silently

Avoid retries, backoff strategies, or complex recovery logic for now.

⸻

What NOT to do at the basic level

Avoid:
	•	Logging raw document text
	•	OCR confidence scores
	•	Page-level spans
	•	Full OpenTelemetry setups
	•	Tool-specific abstractions

These add cognitive load without learning value initially.

⸻

Minimal checklist (start here)

If you want a checklist, this is it:
	•	Generate a document_id for every document
	•	Log one line per document with status
	•	Store document_id in vector metadata
	•	Log embedding model version once per run

When this feels boring, you are ready for the next level.

⸻

How this evolves later (do not implement yet)

Once comfortable, you can add:
	•	Step-level timing (load, chunk, embed)
	•	Checksums and re-ingestion detection
	•	OCR fallback visibility
	•	Full tracing tools (Opik, LangSmith, OpenTelemetry)

But only after the basics are solid.

⸻

Summary

For learning production RAG:
	•	Traceability should be simple and explicit
	•	Logs beat dashboards
	•	IDs beat clever abstractions

This basic setup gives you production-aligned thinking without unnecessary complexity.

# RAG Phase Rules (One Page)

This document defines **clear, minimal rules** for using phases in a Retrieval-Augmented Generation (RAG) system.

It is intentionally short and opinionated. Follow it strictly and you will avoid 90% of observability mistakes.

---

## Purpose of Phases

Phases exist to answer **high-level lifecycle questions**, not implementation details.

They help you understand:

* *When* something happened in the RAG lifecycle
* *Where* failures or latency originate
* *Which* part of the system needs attention

Phases are **structural**, not descriptive.

---

## The Only Phases You Should Use

Use **exactly these four phases**:

| Phase        | Meaning                     |
| ------------ | --------------------------- |
| `INGESTION`  | Offline document processing |
| `QUERY`      | One complete user request   |
| `RETRIEVAL`  | Vector search and reranking |
| `GENERATION` | LLM invocation              |

Do **not** add more phases at the beginning.

---

## Phase Ownership Rules (Critical)

### Rule 1: One QUERY per user request

* Every user question maps to **exactly one** `QUERY` span
* This span is the **root of the trace tree**
* Nothing else should ever be tagged `QUERY`

✅ Correct:

```python
@track(name="generate_answer", phase=Phase.QUERY)
```

❌ Incorrect:

```python
@track(name="format_docs", phase=Phase.QUERY)
```

---

### Rule 2: GENERATION is only for the LLM

`GENERATION` means:

> Tokens are being generated by a model

It applies **only** to:

* Model invocation
* Prompt → completion

✅ Correct:

```python
llm.ainvoke(..., callbacks=[generation_tracer])
```

❌ Incorrect:

* Prompt construction
* Context formatting
* Output parsing

---

### Rule 3: RETRIEVAL is for search, not formatting

`RETRIEVAL` includes:

* Vector similarity search
* Metadata filtering
* Reranking

It does **not** include:

* String concatenation
* Context assembly
* Citation extraction

---

### Rule 4: INGESTION is offline and separate

`INGESTION`:

* Does not happen in response to a user query
* Produces data used later by `RETRIEVAL`
* Lives in separate traces

Never mix `INGESTION` with `QUERY`.

---

## Helper Function Rule

> **Helpers get no phase.**

Helpers are:

* Deterministic
* Fast
* Dependent on a parent phase

Examples:

```python
@track(name="format_docs")
@track(name="extract_citations")
@track(name="parse_llm_output")
```

If a function does not make sense on a dashboard by itself, it does not get a phase.

---

## Correct Trace Shape (Reference)

### Query-time RAG

```
QUERY (rag_query)
 ├── RETRIEVAL (retrieve)
 ├── helper (format_docs)
 └── GENERATION (llm.invoke)
```

### Ingestion-time

```
INGESTION (rag_ingestion)
 ├── load_document
 ├── chunk_document
 └── embed_and_store
```

---

## What Phases Are NOT For

Do **not** use phases for:

* Implementation steps
* Business logic
* Experiment versions
* Environment (dev/prod)

That information belongs in **metadata**, not phases.

---

## Phase Anti-Patterns (Avoid These)

❌ Multiple `QUERY` spans per request
❌ Tagging helpers with `QUERY` or `GENERATION`
❌ Creating phases like `FORMAT`, `POSTPROCESS`, `CONTEXT`
❌ Using phases as tags

---

## Golden Rule (Memorize This)

> **If removing a function would not change system behavior, it must not own a phase.**

---

## Summary

* Phases are **few, coarse, and stable**
* One `QUERY` per request
* `GENERATION` only for the LLM
* Helpers get no phase
* Simplicity now prevents pain later

This phase model scales cleanly from learning projects to production systems.


## Traceability Tags
phase:ingestion
phase:query
phase:retrieval
phase:generation

	•	query phase = the orchestration boundary
	•	generation phase = the LLM call itself

Helper methods should usually have no tags at all.