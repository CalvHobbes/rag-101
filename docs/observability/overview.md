# Observability & Cost Tracking Overview

This document provides detailed implementation guidance for observability, monitoring, and cost tracking in production RAG systems.

## Table of Contents

- [1. Purpose of Observability](#1-purpose-of-observability)
- [2. Observability Tasks & Implementation Choices](#2-observability-tasks--implementation-choices)
  - [Task 0: Abstraction Layer](#task-0-abstraction-layer)
  - [Task 1: Structured Logging](#task-1-structured-logging)
  - [Task 2: LLMOps / Tracing](#task-2-llmops--tracing)
  - [Task 3: Metrics Collection](#task-3-metrics-collection)
  - [Task 4: Cost Tracking](#task-4-cost-tracking)
- [3. Observability Guarantees](#3-observability-guarantees)
- [4. RAG Phase Rules](#4-rag-phase-rules)
  - [The Only Phases You Should Use](#the-only-phases-you-should-use)
  - [Phase Ownership Rules](#phase-ownership-rules-critical)
  - [Helper Function Rule](#helper-function-rule)
  - [Execution Mode Tags](#execution-mode-tags-best-practice)

---

## 1. Purpose of Observability

Provide **visibility into system behavior**, **costs**, and **performance**.

Observability enables:
- debugging production issues
- tracking LLM costs
- identifying optimization opportunities

Observability does **not**:
- modify system behavior
- block requests
- replace testing

---

## 2. Observability Tasks & Implementation Choices

### Task 0: Abstraction Layer

**Goal:**  
Decouple application code from specific observability vendors.

**Tasks:**
- Implement a vendor-agnostic tracing interface
- Centralize observability initialization
- Ensure zero-dependency coupling in core modules

**Implementation:**
- Facade pattern
- Type-safe phase tagging

---

### Task 1: Structured Logging

**Goal:**  
Capture inspectable logs for every operation.

**Tasks:**
- Log all ingestion runs with file counts, durations
- Log all queries with latency, chunk counts
- Log all LLM calls with token usage

**Implementation:**
- Python `logging` with JSON formatter
- `structlog` for structured logging
- Correlation IDs for request tracing

**What to Log:**
- Timestamps
- Operation type
- Input/output sizes
- Latencies
- Errors with stack traces

---

### Task 2: LLMOps / Tracing

**Goal:**  
Deep visibility into LLM interactions.

**Tasks:**
- Trace every LLM call (prompt, response, tokens, latency)
- Aggregate traces into datasets
- Enable prompt debugging and iteration

**Tools:**
- **LangFuse** (open-source, self-hostable)
- **LangSmith** (LangChain ecosystem)
- **Opik** (Comet)
- **Pydantic Logfire**

**Recommended Start:**
- LangFuse (free tier, easy setup)
- Integrate via decorator or context manager

**Important:**
- Add tracing from day one
- Cost of not having visibility >> cost of tooling

---

### Task 3: Metrics Collection

**Goal:**  
Track quantitative system health.

**Tasks:**
- Request latency (p50, p95, p99)
- Token usage per request
- Error rates
- Queue depths (if async)

**Implementation:**
- Prometheus metrics
- FastAPI middleware for request metrics
- Custom counters for business metrics

---

### Task 4: Cost Tracking

**Goal:**  
Monitor and control LLM spend.

**Tasks:**
- Track tokens per model per request
- Calculate costs using pricing tables
- Alert on budget thresholds

**Implementation:**
- Log token counts from API responses
- Aggregate in observability tool or custom dashboard
- Set up alerts (daily spend, anomaly detection)

---

## 3. Observability Guarantees

At the end of observability setup:
- Every LLM call is traced
- Costs are tracked per request
- Debugging is possible without code changes
- Alerts exist for anomalies

---

## 4. RAG Phase Rules

This section defines **clear, minimal rules** for using phases in tracing.

### Purpose of Phases

Phases exist to answer **high-level lifecycle questions**, not implementation details.

They help you understand:
- *When* something happened in the RAG lifecycle
- *Where* failures or latency originate
- *Which* part of the system needs attention

Phases are **structural**, not descriptive.

---

### The Only Phases You Should Use

Use **exactly these four phases**:

| Phase        | Meaning                     |
| ------------ | --------------------------- |
| `INGESTION`  | Offline document processing |
| `QUERY`      | One complete user request   |
| `RETRIEVAL`  | Vector search and reranking |
| `GENERATION` | LLM invocation              |

Do **not** add more phases at the beginning.

---

### Phase Ownership Rules (Critical)

#### Rule 1: One QUERY per user request

- Every user question maps to **exactly one** `QUERY` span
- This span is the **root of the trace tree**
- Nothing else should ever be tagged `QUERY`

âœ… Correct:
```python
@track(name="generate_answer", phase=Phase.QUERY)
```

âŒ Incorrect:
```python
@track(name="format_docs", phase=Phase.QUERY)
```

---

#### Rule 2: GENERATION is only for the LLM

`GENERATION` means:
> Tokens are being generated by a model

It applies **only** to:
- Model invocation
- Prompt â†’ completion

âœ… Correct:
```python
llm.ainvoke(..., callbacks=[generation_tracer])
```

âŒ Incorrect:
- Prompt construction
- Context formatting
- Output parsing

---

#### Rule 3: RETRIEVAL is for search, not formatting

`RETRIEVAL` includes:
- Vector similarity search
- Metadata filtering
- Reranking

It does **not** include:
- String concatenation
- Context assembly
- Citation extraction

---

#### Rule 4: INGESTION is offline and separate

`INGESTION`:
- Does not happen in response to a user query
- Produces data used later by `RETRIEVAL`
- Lives in separate traces

Never mix `INGESTION` with `QUERY`.

---

### Helper Function Rule

> **Helpers get no phase.**

Helpers are:
- Deterministic
- Fast
- Dependent on a parent phase

Examples:
```python
@track(name="format_docs")
@track(name="extract_citations")
@track(name="parse_llm_output")
```

If a function does not make sense on a dashboard by itself, it does not get a phase.

---

### Correct Trace Shape (Reference)

**Query-time RAG:**
```
QUERY (rag_query)
 â”œâ”€â”€ RETRIEVAL (retrieve)
 â”œâ”€â”€ helper (format_docs)
 â””â”€â”€ GENERATION (llm.invoke)
```

**Ingestion-time:**
```
INGESTION (rag_ingestion)
 â”œâ”€â”€ load_document
 â”œâ”€â”€ chunk_document
 â””â”€â”€ embed_and_store
```

---

### What Phases Are NOT For

Do **not** use phases for:
- Implementation steps
- Business logic
- Experiment versions
- Environment (dev/prod)

That information belongs in **metadata**, not phases.

---

### Phase Anti-Patterns (Avoid These)

âŒ Multiple `QUERY` spans per request  
âŒ Tagging helpers with `QUERY` or `GENERATION`  
âŒ Creating phases like `FORMAT`, `POSTPROCESS`, `CONTEXT`  
âŒ Using phases as tags

---

### Golden Rule (Memorize This)

> **If removing a function would not change system behavior, it must not own a phase.**

---

### Execution Mode Tags (Best Practice)

When the same phase can be triggered via different execution paths, use **tags** to distinguish:

```python
# Workflow execution (DBOS durable workflows)
@track(name="ingest_folder_workflow", phase=Phase.INGESTION, tags=["execution:workflow"])

# Manual/script execution
@track(name="ingest_folder", phase=Phase.INGESTION, tags=["execution:manual"])
```

**Filtering in Opik:**
- `phase:ingestion` â†’ all ingestion
- `phase:ingestion AND execution:workflow` â†’ workflow runs only
- `phase:ingestion AND execution:manual` â†’ script runs only

This keeps phases stable and coarse while allowing fine-grained filtering.

---

### Summary

- Phases are **few, coarse, and stable**
- One `QUERY` per request
- `GENERATION` only for the LLM
- Helpers get no phase
- Use **tags** for execution modes, not phases
- Simplicity now prevents pain later

This phase model scales cleanly from learning projects to production systems.

> **ğŸ“– For beginner-friendly traceability guidance**, see [Traceability Basics](traceability-basics.md)
